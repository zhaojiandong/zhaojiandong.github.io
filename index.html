<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>




  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Source Code Cracker">
<meta property="og:url" content="http://zhaojiandong.github.io/index.html">
<meta property="og:site_name" content="Source Code Cracker">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Source Code Cracker">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

  <title> Source Code Cracker </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-67786766-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?191d406b7f02a0157adb6db364ad7b30";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Source Code Cracker</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/java-class-loader/" itemprop="url">
                Java类加载器详解
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-10-20T18:16:52+08:00" content="2015-10-20">
            2015-10-20
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/java-class-loader/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="java-class-loader/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="Java三种类型的类加载器">Java三种类型的类加载器</h2><ul>
<li>我们首先看一下JVM预定义的三种类型类加载器，当一个 JVM 启动的时候，Java 缺省开始使用如下三种类型类装入器：</li>
<li><strong>启动类加载器(Bootstrap Class Loader)</strong>：引导类装入器是用本地代码实现的类装入器，它负责将 <java_runtime_home>/lib 下面的类库加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</java_runtime_home></li>
<li><strong>标准扩展类加载器（Extensions Class Loader）</strong>：扩展类加载器是由 Sun 的 ExtClassLoader （sun.misc.Launcher$ExtClassLoader） 实现的。它负责将 &lt; Java_Runtime_Home &gt;/lib/ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。</li>
<li><strong>系统类加载器（System Class Loader ）</strong>：系统类加载器是由 Sun 的 AppClassLoader （sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（classpath）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。</li>
</ul>
<h2 id="类加载双亲委派机制介绍">类加载双亲委派机制介绍</h2><p><strong>为什么是双亲委派机制</strong>：java.lang.String类在rt.jar中，在JVM启动时由BootStrap启动类加载器加载；当用户自定义的加载器也需要加载java.lang.String类时，如果自定义的加载器不请求双亲加载（检查双亲是否已经加载），就会有2个java.lang.String类了。所以双亲委派机制解决了这个问题：一个类加载器在接收到类加载请求的时候，首先将其委托给父类加载器，如果父类加载器可以完成类加载任务，就成功返回；如果父类加载器无法完成加载任务时，才去自己加载。</p>
<p><strong>双亲委派机制很好解决了各个类加载器类加载的统一问题。</strong><br><img src="http://7xlamb.com1.z0.glb.clouddn.com/classloaderClassLoader1.gif" alt="Alt text"><br>系统类加载器的父类加载器是标准扩展类加载器，标准扩展类加载器的父类加载器是启动类加载器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">		System.out.println(ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line">		System.out.println(ClassLoader.</span><br><span class="line">			getSystemClassLoader().getParent().getParent());                                                            </span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过ClassLoader.getSystemClassLoader()可以直接获取到系统类加载器</strong>， 系统类加载器父类是扩展类加载器， 扩展类加载器的父类则是启动类加载器，在JVM中的体现是null，因为启动类加载器是用native的c++实现的。以上代码结果如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@197d257</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@7259da</span><br><span class="line">null</span><br></pre></td></tr></table></figure></p>
<p>通过以上的代码输出，我们可以判定系统类加载器的父加载器是扩展类加载器， 但是我们试图获取启动类加载器的父类加载器时确得到了null， 就是说扩展类加载器本身强制设定父类加载器为null。我们还是借助于代码分析一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        security.checkCreateClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认将父类加载器设置为系统类加载器，getSystemClassLoader()获取系统类加载器</span></span><br><span class="line">    <span class="keyword">this</span>.parent = getSystemClassLoader();</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">       security.checkCreateClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//强制设置父类加载器</span></span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程上下文类加载器(Thread_Context_Claass_Loader,TCCL)">线程上下文类加载器(Thread Context Claass Loader,TCCL)</h2><p>双亲委派机制解决了类重复加的问题，但是不能解决应用开发中遇到的全部类加载问题。双亲委派机制中，上层父类的加载器不可以使用子类加载的对象。而有些时候程序的确需要父类调用子类对象，这时候就需要线程上下文加载器来处理。</p>
<blockquote>
<p>Java 提供了很多服务提供者接口(Service Provider Interface，SPI)，允许第三方为这些接口提供实现。 以JNDI为例，它的核心接口是由JRE核心类(rt.jar)实现的，由启动类加载器加载。但是在这核心类JNDI的实现是由第三方厂商实现的，由系统类加载器加载。启动类加载器是无法找到第三方实现类，因为它只加载 Java 的核心库。</p>
<p>但这些核心接口的实现类必须能加载由第三方厂商提供的JNDI实现。这种情况下父类请求子类加载器去完成类加载任务（这个类只有子类加载器可见），双亲委派机制就会失效。解决办法就是让核心JNDI类使用线程上下文类加载器，从而有效的打通类加载器层次结构，逆着代理机制的方向使用类加载器。</p>
</blockquote>
<p><strong>线程上下文类加载器(Thread Context ClassLoader) </strong><br>线程上下文加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，默认是系统类加载器。</p>
<h3 id="Thread_Context_Class_Loader(TCCL)">Thread Context Class Loader(TCCL)</h3><blockquote>
<p>TCCL is a hack that was added in Java 1.2 to support J2EE. Specifically it was needed to support things like Entity Beans; in a modern world it’s used to support technologies like JPA, JAXB, Hibernate and so on.</p>
</blockquote>
<p>先来看个TCCL的例子，自定义类加载器myUrlCl（URLClassLoader）<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyURLClassLoaderTest&#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;	</span><br><span class="line">	URL[] baseUrls = &#123; URL("file:D:/java_tools/maven2/m2/repository</span><br><span class="line">	/com/xxx/common/common-test/1.0-SNAPSHOT/</span><br><span class="line">	common-test-1.0-SNAPSHOT.jar")&#125;;</span><br><span class="line">	</span><br><span class="line">	String targetClassName = "com.xxx.common.HelloWorld";</span><br><span class="line">	// 设置系统类加载器为myUrlCl的父类加载器</span><br><span class="line">	ClassLoader systemCl = ClassLoader.getSystemClassLoader();</span><br><span class="line">	// </span><br><span class="line">	ClassLoader myUrlCl = new URLClassLoader(baseUrls,systemCl);</span><br><span class="line">	// 设置TCCL为myUrlCl，</span><br><span class="line">	Thread.currentThread().setContextClassLoader(myUrlCl);</span><br><span class="line">	</span><br><span class="line">	Class targetClass = myUrlCl.loadClass(targetClassName);</span><br><span class="line">	Object targetObj = targetClass.newInstance();</span><br><span class="line">	Object res  = targetClass.getMethod("test").invoke(targetObj);</span><br><span class="line">	System.out.println(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中com/xxx/common/common-test/1.0-SNAPSHOT 这个jar包只有两个类，分别是：Apple.java，HelloWorld.java；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    getter/setter.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HelloWorld.java  创建Apple的对象用Class.forName指定类加载器为TCCL的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    ClassLoader tccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="comment">// appleClass指定类加载器为tccl</span></span><br><span class="line">	Class appleClass = Class.forName(<span class="string">"com.xxx.common.Apple"</span>, <span class="keyword">true</span>, tccl);</span><br><span class="line">	sb.append(<span class="string">"thread_context_classLoader:"</span> + tccl.toString() + <span class="string">"\n"</span>);            </span><br><span class="line">	sb.append(<span class="string">"Apple_Class_classLoader:"</span></span><br><span class="line">			+appleClass.getClassLoader().toString()+<span class="string">"\n"</span>);</span><br><span class="line">            </span><br><span class="line">	<span class="keyword">if</span>(tccl.getParent()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		sb.append(<span class="string">"thread_context_classLoader_parent:"</span>+</span><br><span class="line">			tccl.toString()+<span class="string">"\n"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		sb.append(<span class="string">"thread_context_classLoader_parent:null\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(String.class.getClassLoader()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		sb.append(<span class="string">"String_classLoader:"</span></span><br><span class="line">			+String.class.getClassLoader().toString()+<span class="string">"\n"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		sb.append(<span class="string">"String_classLoader:null\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行MyURLClassLoaderTest.java获取的结果是：加载Apple类的是myUrlCl类加载器，myUrlCl加载器的父类加载器是系统类加载器，和ClassLoader myUrlCl = new URLClassLoader(baseUrls,systemCl)的设置符合；加载String的是启动类加载器。输出的结果如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_context_classLoader:java.net.URLClassLoader@1c90a278</span><br><span class="line">Apple_Class_classLoader:java.net.URLClassLoader@1c90a278</span><br><span class="line">thread_context_classLoader_parent:sun.misc.Launcher$AppClassLoader@4e7a15b</span><br><span class="line">String_classLoader:null</span><br></pre></td></tr></table></figure></p>
<p> 如果在HelloWorld.java中有main方法调用test方法，结果：加载Apple的是系统类加载器；加载String的是启动类加载器。输出结果如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_context_classLoader:sun.misc.Launcher$AppClassLoader@4e7a15b</span><br><span class="line">Apple_Class_classLoader:sun.misc.Launcher$AppClassLoader@4e7a15b</span><br><span class="line">thread_context_classLoader_parent:sun.misc.Launcher$ExtClassLoader@3125fe1</span><br><span class="line">String_classLoader:null</span><br></pre></td></tr></table></figure></p>
<p> 栗子演示完毕，是不是有点迷惑：为什么不直接加载common-test-1.0-SNAPSHOT 这个jar包的下面的类。 这种类加载设计应用场景是什么？其中一个应用场景是Tomcat的启动类就是应用了这种特性。<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/tomcat_classloader1.jpg" alt="tomcat_classloader"><br>每一个WebApp Class Loader都会有个统一的启动方法start（或者init），Catalina ClassLoader（类似于上例中的MyURLCl）加载WebAppClassLoader，这样就能做到每个WebApp间接依赖的下游的类，即使类限定名一直也不会发生冲突，这就是类隔离的。</p>
<blockquote>
<p>JVM唯一标识一个类：类加载器+类限定名</p>
</blockquote>
<p>有一个点留给读者思考，如果MyURLClassLoaderTest中注释掉以下代码，执行结果是怎么样的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().setContextClassLoader(myUrlCl);</span><br></pre></td></tr></table></figure></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/hexo-optimization1/" itemprop="url">
                Hexo 博客优化(NexT主题)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-09-20T21:23:42+08:00" content="2015-09-20">
            2015-09-20
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/hexo-optimization1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="hexo-optimization1/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="1-数据统计">1.数据统计</h2><h3 id="百度统计">百度统计</h3><ul>
<li>next 主题配置项 _config.yml新增字段: baidu_analytics</li>
<li>baidu_analytics值设置成你的<a href="http://tongji.baidu.com/" target="_blank" rel="external">百度统计脚本id</a><br><img src="http://7xlamb.com1.z0.glb.clouddn.com/analytics-baidu-id.png" alt="Alt text"></li>
</ul>
<h3 id="Google统计">Google统计</h3><ul>
<li>_config.yml新增字段: google_analytics</li>
<li>google_analytics值设置成你的<a href="https://www.google.com/analytics" target="_blank" rel="external">Google跟踪ID</a>。跟踪ID通常是以UA-开头<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/analytics-google.png" alt="Alt text"></li>
</ul>
<h2 id="2-_多说评论">2. 多说评论</h2><ul>
<li>使用多说前需要先在 多说 创建一个站点。具体步骤如下：</li>
</ul>
<blockquote>
<p>1.登录后在首页选择 “我要安装”。<br> 2.创建站点，填写表单。多说域名 这一栏填写的即是你的 duoshuo_shortname，如图：</p>
</blockquote>
<p><img src="http://7xlamb.com1.z0.glb.clouddn.com/duoshuo-create-site.png" alt="Alt text"></p>
<blockquote>
<p>3.创建站点完成后在 站点配置文件 中新增 duoshuo_shortname 字段，值设置成上一步中的值。</p>
</blockquote>
<h2 id="3-_SiteMap_搜索收录">3. SiteMap 搜索收录</h2><p>安装插件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-baidu-sitemap <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure>
<p>在执行hexo站点配置_config.yml，执行hexo g在public文件夹下生成了sitemap.xml和baidusitemap.xml</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">sitemap:</span></span><br><span class="line"><span class="label">path:</span> sitemap.xml</span><br><span class="line"><span class="label">baidusitemap:</span></span><br><span class="line"><span class="label">path:</span> baidusitemap.xml</span><br></pre></td></tr></table></figure>
<h3 id="3-1_google提交sitemap-xml">3.1 google提交sitemap.xml</h3><ul>
<li>网址（需要翻墙）<a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">google Search Console</a></li>
<li>添加属性（或者添加站点）<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/next-optgoogle_sitemap1.JPG" alt="google_sitemap提交1"><br><img src="http://7xlamb.com1.z0.glb.clouddn.com/next-optgoogle_sitemap2.JPG" alt="google_sitemap提交2"></li>
</ul>
<h3 id="3-2_百度提交sitemap-xml">3.2 百度提交sitemap.xml</h3><ul>
<li>百度sitemap提交的品台是<a href="http://zhanzhang.baidu.com/dashboard/index" target="_blank" rel="external">百度站长平台</a></li>
<li>站点管理-添加站点</li>
<li>网页抓取-链接提交<img src="http://7xlamb.com1.z0.glb.clouddn.com/next-optbaidu_sitemap1.JPG" alt="百度_sitemap提交1"></li>
<li>百度抓取不成功是因为gitpage屏蔽了百度爬虫，解决方法网上有些。但是因为对百度也不抱什么希望，就没有试验，google提交了sitemap很快可以检索到了！</li>
</ul>
<h2 id="4-_Hexo_问题">4. Hexo 问题</h2><ol>
<li>deploy 无效的情况<blockquote>
<p>删除.deploy_git文件夹并且执行hexo clean后，重新hexo deploy</p>
</blockquote>
</li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/mysql-base/" itemprop="url">
                mysql-base
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-08-09T23:55:32+08:00" content="2015-08-09">
            2015-08-09
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/mysql-base/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="mysql-base/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/scc-asm/" itemprop="url">
                SourceCode Crack——ASM
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-08-09T23:55:08+08:00" content="2015-08-09">
            2015-08-09
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/scc-asm/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="scc-asm/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="前言">前言</h2><ul>
<li><a href="http://asm.ow2.org/" target="_blank" rel="external">ASM 是什么</a><blockquote>
<ol>
<li>官方介绍：ASM is an all purpose Java bytecode manipulation and analysis framework. It can be used to modify existing classes or dynamically generate classes, directly in binary form. </li>
<li>ASM是一个多用途的Java字节码操作和分析框架。它可以被用来修改现有类或动态生成的类，直接以二进制形式</li>
<li>ASM 应该是 Assembly缩写(官方没有缩写介绍，个人理解)</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="哪些著名的框架使用了ASM">哪些著名的框架使用了ASM</h2><ul>
<li>Languages and AOP tools: AspectWerkz | AspectJ | BeanShell | CGLIB | dynaop | Clojure | Groovy </li>
<li>Java ME: EclipseME | MicroEmulator Sun Java ME emulation for Java SE |</li>
<li>Tools and frameworks: Fractal | Dr. Garbage | Proactive | Retrotranslator | RIFE | R-OSGi | Terracotta </li>
<li>Persistence: EasyBeans | Ebean | JDBCPersistence | JPOX | OpenEJB | Oracle BerkleyDB </li>
<li>Monitoring: BEA WebLogic | BTrace | Byteman | JiP | ByCounter | Limpid Log</li>
<li>Testing and code analysis: Agitar | Cobertura | Eclipse | JCarder | SemmleCode | Structure101 | SonarJ </li>
</ul>
<hr>
<h2 id="ASM特点">ASM特点</h2><ol>
<li>短小精悍、快速、健壮</li>
<li>具有很好的文档，并且还有eclipse\Idea插件</li>
<li>开源</li>
</ol>
<hr>
<h2 id="ASM_Core框架">ASM Core框架</h2><hr>
<h2 id="ClassVisit接口实现">ClassVisit接口实现</h2><hr>
<h2 id="ClassReader实现">ClassReader实现</h2><hr>
<h2 id="ClassWriter实现">ClassWriter实现</h2><hr>
<h2 id="例子1：类生成">例子1：类生成</h2><hr>
<h2 id="jvm的命令行介绍">jvm的命令行介绍</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">javap</span> -verbose 查看类信息</span><br><span class="line">javap -c 查看bytecode</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="使用_ASM_实现_Java_语言的“多重继承”">使用 ASM 实现 Java 语言的“多重继承”</h2><p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-asm/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-lo-asm/</a></p>
<hr>
<h2 id="插件ByteCode_Outline使用介绍">插件ByteCode Outline使用介绍</h2></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/jvm-base/" itemprop="url">
                JVM垃圾收集算法
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-08-09T23:55:08+08:00" content="2015-08-09">
            2015-08-09
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/jvm-base/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="jvm-base/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="JVM垃圾收集">JVM垃圾收集</h1><h2 id="1-_判断对象是否存活">1. 判断对象是否存活</h2><ul>
<li><p>引用计数算法<br>对象添加一个引用计数器，每个地方引用它，计数器值加+1；当引用失效，计算器值减1；任何时刻计数器为0的对象不可能被使用。引用计数算法实现简单，高效。<br>缺点：引用计数算法，很难解决相互引用的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objA.instance = B;</span><br><span class="line">objB.instance = C;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>可达性分析算法</strong><br>主流商用算法，通过一些列的”GC roots” 作为对象的起点，从这些节点开始向下搜索，锁走过的路径成为引用链(reference Chain),当一个对象到GC root没有任何引用链项链，则证明对象不可用。<br>在Java语言中，可以作为回收改对象 GC Roots的对象：<br>  虚拟机栈中引用的对象<br>  方法区中类静态属性引用对象<br>  方法区中常量引用的对象<br>  本地房发展中JNI(一般说的Native方法)引用对象</p>
</li>
<li><strong>再谈引用</strong><br>强引用：代码中普遍存在的，object obj = new Object();<br>软引用：有用但非必须的对象<br>弱引用：非必须的对象，当GC工作室，都会被回收<br>虚引用：称为幽灵引用或欢迎引用，最弱的一种引用</li>
</ul>
<hr>
<h2 id="2-_对象生存还是死亡">2. 对象生存还是死亡</h2><p> <strong>对象判断死亡需要经历两次标记过程：</strong></p>
<ol>
<li>如果对象在进行可达性分析后发现没有与GC roots相连的引用链，那它将会第一次标记并进行一个三选，删选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种方法视为“没有必要执行”。如果这个对象有必要执行finalize()方法，那么这个对象会被放置在一个叫F-Queue的队列中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里所谓的“执行”及时虚拟机会触发这个方法，并承诺会等它运行结束。</li>
<li>第二次小规模的标记，如果对象要在finaliz()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如自己(this关键字)复制给某个变量或对象的成员变量，那第二次标记时它将被移除“即将回收”的集合；如果对象这时候没有逃脱，那基本上它就真的要被回收了。</li>
</ol>
<ul>
<li><strong>回收方法区</strong><br>方法区也就是永久代也需要回收，两部分内容：废弃常量和无用的类。<br>判断常量是否需要回收：Java堆中常量回收没有对象引用这个常量，也没有其他地方引用这个字面量。</li>
</ul>
<p>判定类是否需要回收:</p>
<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对应的java.lang.Class对象没有任何的地方被引用，无法再任何地方通过反射访问该类的方法</li>
</ol>
<hr>
<h2 id="3-垃圾收集算法">3.垃圾收集算法</h2><ul>
<li><p><strong>标记-清除算法(Mark-Sweep)</strong><br>分成两个过程，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。缺点是：1效率问题；2空间问题，大量不连续的内存碎片</p>
</li>
<li><p><strong>复制算法</strong>：<br>复制算法可以解决效率问题，标记号需要回收的对象，复制到内存的另一块中去。缺点：空间利用率问题。<br>现在的商业虚拟机中，都是“朝生夕死”的对象，可以不按照１:１比例来划分内存空间，而将内存分成一块较大的Eden空间，2块较小的Survivor空间。当回收时，copy Eden空间和1块from Survivor空间中存活的对象到另一块to survivor空间中。</p>
</li>
<li><p><strong>标记-整理(Mark-Compact)</strong><br>标记过程和Mark-Sweep一样，整理是将存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
</li>
</ul>
<hr>
<h3 id="3-1_分代收集算法">3.1 分代收集算法</h3><ul>
<li>新生代：每次收集都有大批对象死去，只有少量存活，复制算法，只需复制少量存活的对象。所以新生代大多数是stop-the-world收集器。</li>
<li>老年代：对象存活率高，没有额外空间，必须使用“标记-清理”或“标记-整理”</li>
<li>Eden:绝大部分对象存在Eden区域。当Java创建非常大的对象时JVM会分配在老年代而非新生代。每次收集完Eden空间总是空的。</li>
<li><p>Survivor空间：在垃圾收集过程设有被当做垃圾收集的对象存放该区域，也就是Survivor域的对象至少经历一次回收。Eden和1个Survivor空间中存活的对象被复制到另一个Survivor空间，同时清理掉Eden和Survivor空间。<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/GC分代" alt="Alt text"></p>
</li>
<li><p>枚举根节点：<br>JVM停顿下来后，并不需要一个不漏地检查完所有的引用，JVM通过一组OopMap的数据结构来直接得知哪些地方存放着对象引用。<br>在类加载完成时，JVM把对象在内存中偏移量计算出来，保存在OopMap中。这样GC在扫描引用时，可以直接得知引用关系了。</p>
</li>
<li>安全点(safepoint)：<br>在OopMap协助下，JVM可以快速准确地完成GC Root枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令很多，如果为每一条指令生成对应的OopMap，那将会需要大量的额外空间。实际上，JVM的确没有为没一条指令生成OopMap，只有特定位置记录了这些信息，这些位置成为安全点(sagfePoint)。方法调用、循环跳转、异常跳转等功能的指令才会生成SafePoint。<br><strong>如何让所有线程在GC时停顿下来：</strong></li>
</ul>
<ol>
<li>抢先式中断：GC发生时，所有线程全部中断，如果发现有线程中断的地方不在safepoint上，就恢复该线程，让它跑到safepoint上。</li>
<li>主动式中断：当GC需要中断线程时，不要直接对线程操作，仅仅简单的设置一个标志，各线程执行时主动去轮询这个标志，发现中断标志时就主动中断挂起。</li>
</ol>
<ul>
<li><p>各种垃圾收集器的图<br>  <img src="http://7xlamb.com1.z0.glb.clouddn.com/垃圾收集器的图.png" alt="Alt text"></p>
</li>
<li><p><strong>Serial收集器</strong><br>单线程，收集的时候停止用户线程，模式stop-the-world<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/jvmSerial收集器.png" alt="Alt text"><br>新生代：采用复制算法，复制eden空间中和from Survivor空间的对象，到to Survivor空间中。<br>老年代：采用标记整理算法<br>简单高效，是JVM默认的新生代收集器。</p>
</li>
<li><p><strong>ParNew收集器</strong><br>ParNew收集器其实Serial收集器的多线程版本，除了多线程收集及外，stop-the-world模式。多核处理器，可以充分利用CPU资源，但是在单核中比Serial收集器性能差，因为需要线程切换的开销。<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/jvmParNew收集器.png" alt="Alt text"></p>
</li>
</ul>
<ul>
<li><strong>Parallel Scavenge 收集器</strong><br>吞吐量优先收集器，Parallel Scavenge提供两个参数精确控制吞吐量，分别是控制最大来及停顿时间的-XX:MaxGCPauseMillis参数，以及直接设置吞吐量大小的 -XX：GCTimeRatio参数。吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/jvmParallel%20Scavenge%20收集器.png" alt="Alt text"></li>
</ul>
<ul>
<li>Serial Old 收集器<br>Seri Old收集器是Serial收集器的来年版本，它同样是一个多线程收集器，使用“mark-compact”标记-整理算法。可以和Parallel Scavenge收集器搭配使用；还可以作为CMS收集器的后备预案。<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/jvmSerial%20Old%20收集器.png" alt="Alt text"></li>
</ul>
<ul>
<li><strong>CMS收集器</strong><br>CMS(concurrent-Mark-Sweep) 是一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法<br><strong>CMS回收策略可以设置阀值触发GC，不一定都是Full GC，而 Full GC 需要stop the world</strong><br>过程：<br>初始标记：标记一下GC roots能直接关联的对象，stop-the-world<br>并发标记：和用户程序线程一起并发执行<br>重新标记：为了修正并发标记期间因用户程序继续运行而导致标记残生变动那一部分对象，比初始标记时间长，但远比并发标记时间短，认识stop-the-world模式<br>并发清除：所有不再被应用的对象将从堆里清除掉。<br>并发重置：收集器做一些收尾的工作，以便下一次GC周期能有一个干净的状态。<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/jvm收集器运行示意图.png" alt="Alt text"><br>优点：CMS并发收集，低停顿<br>缺点：1 CMS收集器对CPU敏感，并发的收集器对资源都敏感，会占用用户线程数，推荐1/cpu数量<br>2 CMS收集器无法回收浮动垃圾，即并发清除过程中产生的垃圾在标记过后，CMS无法再当次收集中处理掉他们，只好留待下一次GC再清理<br>3 基于标记-清除算法意味着会产生大量空间碎片，空间碎片过多，将会给大对象分配带来麻烦。会提前触发一次Full GC。+UseCMSCompactAtFullCollection开关参数，用于在CMS收集器顶不住要进行FullGC时开启内存碎片整理过程<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/jvmCMS和Serial%20收集器区别.png" alt="Alt text"><br>  CMS和Serial 收集器区别</li>
</ul>
<ul>
<li><strong>G1收集器</strong><br>G1(Garbage-first)收集器是当今最前沿的成果，JDK1.7中试用,7u4<br><img src="http://7xlamb.com1.z0.glb.clouddn.com/jvmG1收集器.png" alt="Alt text"><br><strong>特点：</strong></li>
</ul>
<ol>
<li>并发与并行：</li>
<li>分代收集</li>
<li>空间整合：</li>
<li>可预测的停顿：<br>G1收集器，Java堆的内存布局就与其他收集器有很大差别，他将整个Java堆划分成多个大小相等的独立区域(region)，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理上的隔离，它们都是一部分Region(不需要连续)的集合。<br>G1收集器中，Region之间的对象引用以及其他收集器中新生代与老年代之间对象引用，虚拟机都使用Remembered Set来避免全堆的扫描。G1中每个Region都有一个与之对象的Remembered Set，JVM发现程序对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，边通过CardTable把引用信息记录到被引用的对象的所属的region的Remembered Set之中。当进行内存回收时，GC根节点的美剧范围中加入Remembered Set 即可保证部队全堆扫描也不会遗漏。<br><strong>G1收集器大致过程：</strong></li>
<li>初始标记(Initial Marking)：比较GC Roots能直接关联到的对象。</li>
<li>并发标记(Concurrent Marking)：耗时长，和用户线程并发执行</li>
<li>最终标记(Final marking)：为了修正并发标记期间因用户线程继续运作而导致标记产生变化的那部分记录，重新标记</li>
<li>筛选回收(Live Data Counting and Evacution)：回收阶段首先对各个Region的回收价值和成本进行排序，根据用户期望的停顿时间来指定回收计划，这一过程可以和用户并发。</li>
</ol>
<hr>
<h2 id="4-_关于Full_GC">4. 关于Full GC</h2><blockquote>
<p>当老年代对象大小达到阈值时，便会触发一次Full GC（Full GC一般会伴随一次minor GC），Full GC很消耗内存，把 老年代和新生代 里面大部分垃圾回收掉。这个时候用户线程都会被block住（stop-the-world）。<br>老年代都会采用 标记-整理-压缩，虽是一个耗时操作，但为了提高老年代空间的利用率，减少Full GC次数，是必要的。</p>
</blockquote>
<h2 id="5-理解GC日志">5.理解GC日志</h2><p>开启GC日志：<br>-XX:+PrintGC 或者 -verbose:gc  开启了简单GC日志模式<br>-XX:PrintGCDetails，就开启了详细GC日志模式。在这种模式下，日志格式和所使用的GC算法有关<br>-XX:+PrintGCTimeStamps可以将时间和日期也加到GC日志中。表示自JVM启动至今的时间戳会被添加到每一行中<br>-XX:+PrintGCDateStamps，每一行就添加上了绝对的日期和时间<br>-Xloggc:也可以输出到指定的文件。需要注意这个参数隐式的设置了参数-XX:+PrintGC和-XX:+PrintGCTimeStamps，但为了以防在新版本的JVM中有任何变化，我仍建议显示的设置这些参数</p>
<p>GC 表示垃圾收集类型，Full GC需要Stop-the-world<br>[DefNew [PsYongGen 表示表示收集器区域和收集器名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>: [GC [DefNew: <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">3712</span>K), <span class="number">0.0025925</span> secs] <span class="number">3324</span>K-&gt;<span class="number">152</span>K(<span class="number">11904</span>K), <span class="number">0.0031680</span> secs]  </span><br><span class="line"><span class="number">100.667</span>: [Full GC [Tenured: <span class="number">0</span>K-&gt;<span class="number">210</span>K(<span class="number">10240</span>K), <span class="number">0.0149142</span> secs] <span class="number">4603</span>K-&gt;<span class="number">210</span>K(<span class="number">19456</span>K), [Perm : <span class="number">2999</span>K-&gt;<span class="number">2999</span>K(<span class="number">21248</span>K)], <span class="number">0.0150007</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure>
<p>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。<br>    GC日志开头的“［GC”和“［Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“［Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示［Full GC (System)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC <span class="number">283.736</span>: [ParNew: <span class="number">261599</span>K-&gt;<span class="number">261599</span>K(<span class="number">261952</span>K), <span class="number">0.0000288</span> secs]</span><br></pre></td></tr></table></figure>
<p>接下来的“［DefNew”、“［Tenured”、“［Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“［DefNew”。如果是ParNew收集器，新生代名称就会变为“［ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。<br>    后面方括号内部的“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt; GC后该内存区域已使用容量 (该内存区域总容量)”。而在方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量 (Java堆总容量)”。<br>    再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“［Times： user=0.01 sys=0.00， real=0.02 secs］”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。</p>
<h3 id="5-1_Full_GC触发的4种条件">5.1 Full GC触发的4种条件</h3><ol>
<li>老年代空间不足： outofmemoryError:java heap space</li>
<li>永久代空间满：存放class信息，当系统通过反射加载的类过多时需要清理 outofmemoryError:permanet generation</li>
<li>CMS GC时出现promotion failed和concurrent mode failure可能触发Full GC，survivor空间不足</li>
<li>统计得到Minor GC晋升到老年代的平均大小大于老年代剩余空间</li>
</ol>
<hr>
<h2 id="6-_内存分配与回收策略">6. 内存分配与回收策略</h2><ol>
<li>对象优先分配在Eden空间<br>当Eden空间不足时，JVM就发起一次MinorGC。</li>
<li>大对象直接进入老年代<br>大对象是指需要大量连续空间的java对象，大对象对JVM是坏消息，特别是“朝生夕死”的大对象，-XX：PrintenureSizeThreshold参数，另大于这个设置值得对象直接进入老年代。</li>
<li>长期存活的对象将进入老年代<br>Jvm采用分代收集思想 -XX:MaxTenuringThreshold=1，当GC发生1次时对象进行老年代。</li>
<li>动态对象年龄判定<br>JVM不只依赖MaxTenuringThreshold晋升老年代，如果Survivor空间中相同年龄所有对象总和大于Survivor空间一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。</li>
<li>空间分配担保<br>在发生MOniorGC之前，JVM 会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么MinorGC可以确保是安全的。如果不成立，则JVM会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的对象的平均大小，如果大于，将尝试着进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于,或者HandlePromotionfailure设置不允许冒险，那时也要改为进行一次FullGC。</li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="ZhaoJiandong" itemprop="image"/>
          <p class="site-author-name" itemprop="name">ZhaoJiandong</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhaoJiandong</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhaojiandong"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
